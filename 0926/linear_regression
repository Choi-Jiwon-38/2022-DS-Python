import torch

# y = 2xa + 3xb - 4 에 대한 결과 (x_train / y_train)
x_train = torch.FloatTensor([[1, 2], [3, 2], [3, 7], [1, 1], [1, 0]])
y_train = torch.FloatTensor([[4], [8], [23], [1], [-2]])
print(x_train.shape)

lr = 0.001


# w와 b를 초기화 해주어야 함 (random한 값이나 0을 넣음 | random한 값을 넣었을 때가 평균적으로 효율이 좋음)
w = torch.randn(2, 1)   # mm을 할 때, col <-> row의 수를 맞춰주는 것이 좋으므로 shape을 2, 1로 설정
b = torch.randn(1)      # b는 상수이므로 차원을 1로 설정하여도 상관 X

for epoch in range(100):
    w.requires_grad_(True) # for 문을 돌며 requires_grad가 계속 초기화되어 for문 처음에 True로 변경
    b.requires_grad_(True) # 위와 동일

    h = torch.mm(x_train, w) + b
    cost = torch.mean((y_train - h) ** 2)
    # b.grad <- 편미분한 값

    cost.backward()

    with torch.no_grad():      # 계산된 결과만 사용 가능, 기울기 계산 X
        w = w - lr * w.grad    # w.grad <- 편미분한 값
        b = b - lr * b.grad
        print(f"w={w}, b={b}, cost={cost}")


x_test = torch.tensor([[5, 10]], dtype=torch.float)
h_test = torch.mm(x_test, w) + b
print(h_test)